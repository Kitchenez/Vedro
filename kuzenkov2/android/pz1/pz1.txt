Требуется в draw.io нарисовать use-case диаграмму приложения под android на языке java. А также выполнить задание: 
Продумать функционал своего собственного приложения и сформировать диаграмму вариантов использования. 
В дальнейших практических занятиях, будет реализовываться функционал, указанный в диаграмме. Так что оно должно быть простым в реализации, а также приложение должно содержать следующие функциональные возможности: 
1. Авторизация в приложении.
2. Взаимодействия с каким-либо внешним сервисом, возвращающим данные о стоимости валюты, погоды и т.д. в виде json-формата. Возможно использовать сервисы типа https://www.wiremock.io/, https://mockapi.io/, https://github.com/typicode/json-server, https://thecatapi.com/ и т.д.
3. Сохранение данных в БД.
4. Отображение списка каких-либо сущностей с изображениями.
5. Отображение страницы сущности.
6. Различные возможности у авторизованного и гостевого пользователя.
7. Использование обученной модели для распознавания изображений, аудио, маски и т.д. (нужно произвести анализ существующих обученных моделей TenzorFlow Lite, которые желаете использовать в приложении).
Допускается использование собственных use case в приложении.

Теория:
Проектирование сценариев использования (Use Case) в чистой архитектуре играет ключевую роль, так как данный слой описывает конкретные бизнес-процессы и взаимодействие с сущностями (Entities). Сценарии использования управляют потоком данных между различными слоями системы, обеспечивая выполнение бизнес-логики. Важно правильно спроектировать данный слой, чтобы код был легко поддерживаемым и соответствовал требованиям к проекту.
1. Определение бизнес-логики
Первым шагом в проектировании Use Case является четкое понимание и определение бизнес-логики или задачи, которую необходимо решить. Это могут быть сценарии работы с пользователем, обработка запросов или любые другие действия, связанные с бизнес-процессами системы.
Какие задачи должен выполнять пользователь?
Каковы требования к функциональности?
Какие данные используются или изменяются?
Пример: в интернет-магазине сценарий использования может быть оформлен как «Оформление заказа», где пользователь выбирает товары, заполняет информацию о доставке и производит оплату.

2. Идентификация сущностей (Entities)
Сценарии использования взаимодействуют с сущностями (Entities), которые содержат бизнес-правила и логику. Поэтому следующим шагом является определение, какие сущности будут участвовать в этом сценарии. Какие объекты домена будут задействованы?
Какие правила или условия должны соблюдаться?
Пример: для сценария «Оформление заказа» сущностями могут быть «Пользователь», «Товар», «Корзина» и «Заказ».

3. Определение границ (Boundaries)
Важной частью проектирования Use Case является разделение на внешние и внутренние границы. Данный принцип подразумевает четкое разграничение между бизнес-логикой (сущностями и сценариями) и внешними источниками данных (база данных, интерфейсы). Это позволяет избегать зависимости бизнес-логики от инфраструктурных компонентов. Какие данные должны быть получены из внешних систем (например, API, базы данных)? Как будет происходить обмен данными между слоями?
Пример: В сценарии «Оформление заказа» данные о товарах могут быть получены из внешней базы данных через интерфейсы, а обработка платежей через внешний платежный сервис.
4. Создание сценариев (Use Case Flow)
После определения сущностей и границ важно описать, как будет выполняться бизнес-логика в сценарии использования. Это может включать последовательность шагов или действий, которые должны быть выполнены для достижения результата. Какой основной поток операций? Какие условия или проверки должны выполняться? Какие альтернативные или исключительные сценарии могут возникнуть? Пример: для «Оформления заказа» шаги могут быть следующими:
Пользователь добавляет товар в корзину.
Система проверяет наличие товара.
Пользователь вводит данные о доставке и оплачивает заказ.
Система подтверждает заказ и отправляет уведомление.

5. Интерфейсы и контракты (Interfaces and Contracts)
Важной частью проектирования Use Case является создание интерфейсов, через которые сценарий использования будет взаимодействовать с внешними слоями (например, с интерфейсом пользователя или базой данных). Интерфейсы позволяют абстрагироваться от конкретной реализации и упрощают тестирование. 
Какие методы или функции необходимы для выполнения сценария?
Какие параметры и возвращаемые значения требуются?
Пример: В сценарии «Оформление заказа» может быть интерфейс для взаимодействия с платежной системой (например, PaymentGateway), который будет содержать метод processPayment().

6. Обработка ошибок и исключений
В процессе выполнения сценариев могут возникать различные исключительные ситуации (например, ошибка при обработке платежа, отсутствие товара на складе и т.д.). Необходимо определить, как будут обрабатываться такие ситуации, и что должен делать сценарий в случае ошибки.
Какие возможны исключения?
Как система должна реагировать на исключения?
Какие данные или сообщения нужно вернуть пользователю?
Пример: В сценарии «Оформление заказа» может быть проверка на наличие товара перед подтверждением заказа. Если товар отсутствует, сценарий должен вернуть сообщение об ошибке пользователю.

7. Тестируемость сценария использования
Сценарии использования должны быть легко тестируемыми. Для этого следует проектировать сценарии так, чтобы они не зависели от внешних систем. Это достигается путем использования интерфейсов и заглушек (mock-объектов) для замены внешних сервисов.
Как можно изолировать сценарий для тестирования?
Какие зависимости нужно подменить заглушками?
Диаграмма вариантов использования начинается с размещения пользователя приложения (актор) или несколько возможных акторов в случаях, когда одним и тем же приложением пользуются гость, зарегистрированный пользователь, администратор. В терминологии UML, эллипс называется вариантом использования (англ. «use-case»). В общем случае, вариант использования – набор действий, который может быть использован актёром для взаимодействия с системой.
На диаграммах UML для связывания элементов используются различные соединительные линии, которые называются отношениями. Каждое такое отношение имеет собственное название и используется для достижения определённой цели.






Смотри у меня получилась пока такая user case диаграмма моего приложения по прогнозу погоды (см. изображение)
Теперь мне нужно на основе сформированных use case необходимо спроектировать экраны приложения с указанием их зоны ответственности:
Обычно выделяют следующие уровни: presentation, domain, data.
Presentation: отвечает за отображение пользовательского интерфейса и реагирование на его события. Domain: бизнес-логика, изолированная от деталей реализации, определяет правила и операции, как приложение должно взаимодействовать с данными. Data: хранилище данных.














Задание.1
Добавить механизм сохранения/получения информации о любимом фильме с помощью SharedPreferences. Обратите внимание на необходимость передачи context без использования слоя domain.

Реализуем некоторый функционал приложения для просмотра информации о любимом фильме. Необходимо реализовать экран, представленный на рисунке.
В первую очередь необходимо создать директорию с названием domain. Данная директория предназначена для хранения классов, реализующих бизнес-логику приложения. В данной директории необходимо создать класс Movie:
public class Movie {
private int id;
private String name;
public Movie(int id, String name) {
this.id = id;
this.name = name;
}
public String getName() {
return name;
}
}

В первую очередь в domain – директории необходимо создать два класса use-case: SaveFilmToFavoriteUseCase и GetFavoriteFilmUseCase. Стоит учитывать, что в случае модификации структуры возвращаемого значения лучше использовать не набор примитивов, а создать отдельную сущность. В нашем случае сущность Movie уже создана. Требуется создать директорию models в директории domain и перенести файл Movie. Далее реализуем use-case. Внутри данных классов создайте функции, выполняющие соответствующие задачи класса.
public class GetFavoriteFilmUseCase {
public Movie execute(){
return new Movie(3, "Game of thrones");
}
}
public class SaveFilmToFavoriteUseCase {
public boolean execute(Movie movie){
if (movie.getName().isEmpty()){
return false;
}else {
return true;
}
}
}

Отображение списка фильмов на главном экране происходит по нажатию соответствующих кнопок:
public class MainActivity extends AppCompatActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
EditText text = findViewById(R.id.editTextMovie);
TextView textView = findViewById(R.id.textViewMovie);
findViewById(R.id.buttonSaveMovie).setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
Boolean result = new SaveFilmToFavoriteUseCase().execute(new Movie(2, text.getText().toString()));
textView.setText(String.format("Save result %s", result));
}
});
findViewById(R.id.buttonGetMovie).setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
Movie moview = new GetFavoriteFilmUseCase().execute();
textView.setText(String.format("Save result %s", moview.getName()));
}
});
}
}

Далее рассмотрен будет слой data – это слой, который предназначен для хранения данных, получения данных и их отправки. В рассматриваемом примере сущность фильм. Соответственно, в проекте будет MovieRepository. Далее необходимо создать такой репозиторий. Создадим директорию data и внутри нее папку repository. В созданной директории необходимо сформировать класс MovieRepository.
Далее реализуем базовую функциональность по сохранению и передачи данных.
public class MovieRepository {
public boolean saveMovie(Movie movie){
return true;
}
public Movie getMovie(){
return new Movie(1,"Doctor Strange");
}
}

Основной вопрос сейчас должен звучать так: «почему используется модель Movie в другом слое». Действительно, не стоит смешивать классы одного слоя с другим слоем, но в нашем случае ситуация немножко другая. Весь секрет того, почему используются модели в Data слое, на самом деле кроется в том, как use case будет связан вот с этим репозиторием. Домен слой он самый-самый главный и ключевой компонент в приложении, он ни от кого не должен зависеть, то есть у нас слой presentaion может зависеть от домена, data тоже может зависеть, но домен ни от кого не зависит, то есть ни от какого слоя. Слой presentaion может к себе подключить домен, дата тоже может к себе подключить домен, но домен к себе никого подключить не может, то есть если к домену начнем подключать другие слоя, то у нас получится такая проблема, как нарушение solid принципов, а именно сформируется круговая зависимость.
Существует хорошее решение, это использование интерфейсов и его реализация. Необходимо создать интерфейс MovieRepository в слое domain, а его реализацию сделать в слое data. Именно поэтому данный интерфейс имеет право использовать модель из своего слоя. Таким образом в домене также необходимо создать директорию repository, то есть имеется два пакета репозиторий, один пакет репозиторий лежит внутри слоя data, а другой пакет репозиторий лежит внутри домена. Рассмотрим интерфейс из слоя domain.

public interface MovieRepository {
public boolean saveMovie(Movie movie);
public Movie getMovie();
}

Далее необходимо создать реализацию интерфейса в слое data. Класс, реализующий интерфейс общепринято называть с указанием в конце Impl (сокр. от англ. Implementation)

public class MovieRepositoryImpl implements MovieRepository {
@Override
public boolean saveMovie(Movie movie){
return true;
}
@Override
public Movie getMovie(){
return new Movie(1, "Game of throne");
}
}

Теперь необходимо внести изменения в классы use-case.

public class GetFavoriteFilmUseCase {
private MovieRepository movieRepository;
public GetFavoriteFilmUseCase(MovieRepository movieRepository) {
this.movieRepository = movieRepository;
}
public Movie execute(){
return movieRepository.getMovie();
}
}
public class SaveMovieToFavoriteUseCase {
private MovieRepository movieRepository;
public SaveMovieToFavoriteUseCase(MovieRepository movieRepository) {
this.movieRepository = movieRepository;
}
public boolean execute(Movie movie){
return movieRepository.saveMovie(movie);
}
}

Таким образом структура проекта должны выглядеть следующим образом:
-app:
--manifests
--java:
---ru.mirea.kuzenkov.Lesson9:
----data:
-----model
-----repository:
------MovieRepositoryImpl
-----domain:
------models:
-------Movie
------repository:
-------MovieRepository
------usecases:
-------GetFavoriteFilmUseCase
-------SaveMovieToFavoriteUseCase
------presentaion:
-------MainActivity

В MainActivity необходимо внести изменения для того, чтобы в слой domain передавалась реализация репозитория для получения данных.

MovieRepository movieRepository = new MovieRepositoryImpl(this);
findViewById(R.id.buttonSaveMovie).setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
Boolean result = new
SaveMovieToFavoriteUseCase(movieRepository).execute(new Movie(2, text.getText().toString()));
textView.setText(String.format("Save result %s", result));
}
});
findViewById(R.id.buttonGetMovie).setOnClickListener(new View.OnClickListener() {
@Override
public void onClick(View view) {
Movie moview = new GetFavoriteFilmUseCase(movieRepository).execute();
textView.setText(String.format("Save result %s", moview.getName()));
}
});

Результатом интеграции передачи данных с помощью интерфесов является возможность внесение изменений в репозиторий, которые не повлекут никаких изменений в слое domain.











Задание. Требуется создать новый проект «ru.mirea.«фамилия».«название Вашего проекта»». В меню «File | New Project | Empty Views Activity».
Проект - приложение на языке java под android, на первом этапе представляет из себя болванку для дальнейшего наращивания функционала. Создать классы use-case, указанные на этапе проектирования на уровне слоя domain и data. Репозиторий должен вернуть тестовые данные.




Описание проекта:
Проект на первом этапе представляет из себя болванку для дальнейшего наращивания функционала. Создать классы use-case, указанные на этапе проектирования на уровне слоя domain и data. Репозиторий должен вернуть тестовые данные.

Описание приложения
Предлагаю разработать простое приложение под Android на языке Java под названием "WeatherNow".

"WeatherNow" — это приложение для просмотра прогноза погоды, которое предоставляет пользователям возможность получать актуальную информацию о погоде в различных городах. Приложение взаимодействует с внешним сервисом, возвращающим данные о погоде в формате JSON (например, OpenWeatherMap API).

Функциональные возможности приложения:

Авторизация в приложении:

Пользователь может зарегистрироваться и войти в свой аккаунт.
Гостевой режим доступен без авторизации.
Взаимодействие с внешним сервисом:

Приложение запрашивает данные о погоде из внешнего API в формате JSON.
Сохранение данных в БД:

Авторизованные пользователи могут сохранять избранные города в локальную базу данных SQLite.
Отображение списка городов с изображениями:

Приложение отображает список популярных городов с соответствующими изображениями погоды.
Отображение страницы города (сущности):

При выборе города пользователь видит детальный прогноз погоды.
Различные возможности для авторизованных и гостевых пользователей:

Гости могут просматривать погоду, но не могут сохранять избранные города.
Авторизованные пользователи могут сохранять и управлять списком избранных городов.
Использование обученной модели для распознавания изображений:

Приложение использует модель TensorFlow Lite для распознавания погодных условий по фотографии неба, сделанной пользователем.

Пока я выделил такую диаграмму и уровни соответственно, смотри рисунки.


